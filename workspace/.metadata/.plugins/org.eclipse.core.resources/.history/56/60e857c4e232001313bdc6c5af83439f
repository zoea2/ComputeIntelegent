package differentialEvolution;

import java.io.*;
import java.util.Scanner;

public class DE {
	final static int POPSIZE = 100;
	final static int MAXGENS = 100;
	final static int dim = 30;
	static int f;
	static Genotype best;
	static int[][] oArray;
	static int row;
	//static int[][] ME;
	static double[][] MTurn;
	static double[][] MResult;
	public static void init(Genotype[] population,Genotype[] MidPop) throws FileNotFoundException{
		double lbound;
		double ubound;
		String filename = "/home/ryan/testdata/bound" + f + ".txt";
		Scanner input = new Scanner(new File(filename));
		lbound = input.nextDouble();
		ubound = input.nextDouble();
		for(int i = 0;i < Genotype.NVARS;i++){			
			System.out.println(lbound);
			System.out.println(ubound);
			for(int j = 1;j <= POPSIZE;j++){
				population[j].fitness = 0.0;
				//population[j].cfitness = 0;
				//population[j].rfitness = 0;
				population[j].lower[i] = lbound;
				population[j].upper[i] = ubound;
				MidPop[j].lower[i] = lbound;
				MidPop[j].upper[i] = ubound;
				population[j].gene[i] = Math.random() * 
						(population[j].upper[i] - population[j].lower[i]) + 
						population[j].lower[i];
			}
		}
		input.close();
		/*
		PrintWriter output = new PrintWriter(new File("/home/ryan/output.txt"));
		for(int i = 0;i < POPSIZE;i++){
			output.printf("Pop  %f %f %f\n",population[i].gene[0],population[i].gene[1],population[i].fitness);
			//output.printf("MidPop  %f %f %f\n",MidPop[i].gene[0],MidPop[i].gene[1],MidPop[i].fitness);
		}
		output.close();
		*/
	}
	public static void evaluate(Genotype[] population){
		for(int i = 1;i <= POPSIZE;i++){
			double x1 = population[i].gene[0];
			double x2 = population[i].gene[1];
			population[i].fitness = 21.5 + x1 * Math.sin(4*Math.PI*x1)+x2*Math.sin(20*Math.PI*x2);
			//System.out.printf("popsize %d fitness %f \n",i,population[i].fitness);
		}
	}
	public static double funcU(double x,int a,int k,int m){
		if(x > a)
			return (double)(k * Math.pow(x-a, m));
		else if(x <= a && x >= -a)
			return 0;
		else
			return (double)(k * Math.pow(-x - a, m));
	}
	public static void setME(double[][] ME){
		for(int i = 0;i < Genotype.NVARS;i++){
			for(int j = 0;j < Genotype.NVARS;j++){
				if(i == j)
					ME[i][j] = 1;
				else
					ME[i][j] = 0;
			}
		}
	}
	public static void MulMatrix(double[][] M1,double[][] M2){ 
		double[][] temp = new double[Genotype.NVARS][Genotype.NVARS];
		for(int i = 0;i < Genotype.NVARS;i++){
			for(int j = 0;j < Genotype.NVARS;j++){
				temp[i][j] = 0;
				for(int k = 0;k < Genotype.NVARS;k++)
					temp[i][j] += M1[i][k] * M2[k][j];
			}
		}
		M1 = temp.clone();
	}
	public static void MRot(double[][] MTurn,int i,int j){
		setME(MTurn);
		double alpha = (Math.random() - 0.5) * Math.PI * 0.5;
		MTurn[i][i] = Math.cos(alpha);
		MTurn[j][j] = Math.cos(alpha);
		MTurn[i][j] = Math.sin(alpha);
		MTurn[j][i] = -Math.sin(alpha);
	}
	public static void CreateMatrix(double[][] MResult){
		setME(MResult);
		for(int i = 1;i < Genotype.NVARS;i++){
			MRot(MTurn,0,i);
			MulMatrix(MResult,MTurn);
			
		}
		for(int i = 1;i < Genotype.NVARS-1;i++){
			MRot(MTurn,i,Genotype.NVARS-1);
			MulMatrix(MResult,MTurn);
		}
	}
	public static void evaluate(Genotype[] population,int size,int number){
		switch(number){
			case 0:
				for(int i = 1;i <= size;i++){
					double x1 = population[i].gene[0];
					double x2 = population[i].gene[1];
					population[i].fitness = 21.5 + x1 * Math.sin(4*Math.PI*x1)+x2*Math.sin(20*Math.PI*x2);
					//System.out.printf("popsize %d fitness %f \n",i,population[i].fitness);
				}
				break;
			case 1:
				for(int i = 1;i <= size;i++){
					population[i].fitness = 0;
					for(int j = 0;j < Genotype.NVARS;j++){
						population[i].fitness += Math.pow(population[i].gene[j], 2);
					}
				}
				break;
			case 2:
				for(int i = 1;i <= size;i++){
					population[i].fitness = 0;
					double temp = 1;
					for(int j = 0;j < Genotype.NVARS;j++){
						double tempabs = Math.abs(population[i].gene[j]);
						population[i].fitness += tempabs;
						temp *= tempabs;
					}
					population[i].fitness += temp;
				}
				break;
			case 3:
				for(int i = 1; i <= size;i++){
					population[i].fitness = 0;
					for(int j = 0;j < Genotype.NVARS - 1;j++){
						double x1 = population[i].gene[j];
						double x2 = population[i].gene[j+1];
						population[i].fitness += 100 * Math.pow(x2 - Math.pow(x1,2),2) + Math.pow(x1-1,2);
					}
				}
				break;
			case 4:
				for(int i = 1;i <= size;i++){
					population[i].fitness = Math.random();
					while(population[i].fitness == 1)
						population[i].fitness = Math.random();
					for(int j = 0;j < Genotype.NVARS;j++){
						population[i].fitness += j * Math.pow(population[i].gene[j], 4);
					}
				}
				break;
			case 5:
				for(int i = 1;i <= size;i++){
					population[i].fitness = 418.9829 * Genotype.NVARS;
					for(int j = 0;j < Genotype.NVARS;j++){
						double x = population[i].gene[j];
						population[i].fitness -= x * Math.sin(Math.sqrt(Math.abs(x)));
					}
				}
				break;
			case 6:
				for(int i = 1;i <= size;i++){
					population[i].fitness = 0;
					for(int j = 0;j < Genotype.NVARS;j++){
						double x = population[i].gene[j];
						population[i].fitness += Math.pow(x,2) - 10 * Math.cos(2 * Math.PI * x) + 10;
					}
				}
				break;
			case 7:
				for(int i = 1;i <= size;i++){
					population[i].fitness = 20 + Math.E;
					double temp1 = 0;
					double temp2 = 0;
					for(int j = 0;j < Genotype.NVARS;j++){
						temp1 += Math.pow(population[i].gene[j],2);
						temp2 += Math.cos(2 * Math.PI * population[i].gene[j]);
					}
					population[i].fitness += -20 * Math.exp(-0.2 * Math.sqrt(temp1 / Genotype.NVARS))
							 				- Math.exp(temp2 / Genotype.NVARS);
				}
				break;
			case 8:
				for(int i = 1;i <= size;i++){
					population[i].fitness = 0;
					double temp = 1;
					for(int j = 0;j < Genotype.NVARS;j++){
						population[i].fitness += Math.pow(population[i].gene[j], 2);
						temp *= Math.cos(population[i].gene[j] / Math.sqrt(j+1));
					}
					population[i].fitness = population[i].fitness / 4000 - temp + 1;
				}
				break;
			case 9:
				for(int i = 1;i <= size;i++){
					double y1 = 1 + (population[i].gene[0] + 1) / 4;
					double yd = 1 + (population[i].gene[Genotype.NVARS-1] + 1) / 4;
					double temp1 = 10 * Math.pow(Math.sin(Math.PI * y1), 2)
									+ Math.pow(yd-1,2);
					double temp2 = 0;					
					for(int j = 0;j < Genotype.NVARS;j++){
						if(j < Genotype.NVARS-1){
							double yi = 1 + (population[i].gene[j] + 1) / 4;
							double yii = 1 + (population[i].gene[j+1] + 1) / 4;
							temp1 += Math.pow(yi-1,2) * (1 + 10 * Math.pow(Math.sin(Math.PI * yii), 2));
						}
						temp2 += funcU(population[i].gene[j],10,100,4);
					}
					population[i].fitness = temp1 / Genotype.NVARS * Math.PI + temp2; 
				}
				break;
			case 10:
				for(int i = 1;i <= size;i++){
					population[i].fitness = Math.pow(Math.sin(3 * Math.PI * population[i].gene[0]), 2);
					double xd = population[i].gene[Genotype.NVARS-1];
					population[i].fitness += Math.pow(xd-1,2) * (1 + Math.pow(Math.sin(2 * Math.PI * xd), 2));
					double temp = 0;
					for(int j = 0;j < Genotype.NVARS;j++){
						if(j < Genotype.NVARS - 1){
							population[i].fitness += Math.pow(population[i].gene[j] - 1, 2) 
									* (1 + Math.pow(Math.sin(3 * Math.PI * population[i].gene[j+1]), 2));
						}
						temp += funcU(population[i].gene[j],5,100,4);
					}
					population[i].fitness /= 10;
					population[i].fitness += temp;
				}
				break;
			case 11:
				
				break;
			case 12:
				//CreateMatrix(MResult);
				for(int i = 1;i <= size;i++){
					//CreateMatrix(MResult);
					population[i].fitness = 0;
					for(int j = 0;j < Genotype.NVARS;j++){
						double y = 0;
						for(int k = 0;k < Genotype.NVARS;k++){
							y += MResult[j][k] * population[i].gene[k];
						}
						population[i].fitness += Math.pow(y,2) - 10 * Math.cos(2 * Math.PI * y) + 10;
					}
				}
				break;
			case 13:
				for(int i = 1;i <= size;i++){
					//CreateMatrix(MResult);
					double temp1 = 0;
					double temp2 = 0;
					for(int j = 0;j < Genotype.NVARS;j++){
						double y = 0;
						for(int k = 0;k < Genotype.NVARS;k++){
							y += MResult[j][k] * population[i].gene[k];
						}
						temp1 += Math.pow(y, 2);
						temp2 += Math.cos(2 * Math.PI * y);
					}
					population[i].fitness = -20 * Math.exp(-0.2 * Math.sqrt(temp1 / Genotype.NVARS))
							- Math.exp(temp2 / Genotype.NVARS) + 20 + Math.E;
				}
				break;
			case 14:
				for(int i = 1;i <= size;i++){
					//CreateMatrix(MResult);
					population[i].fitness = 0;
					double temp = 1;
					for(int j = 0;j < Genotype.NVARS;j++){
						double y = 0;
						for(int k = 0;k < Genotype.NVARS;k++){
							y += MResult[j][k] * population[i].gene[k];
						}
						population[i].fitness += Math.pow(y,2);
						temp *= Math.cos(y / Math.sqrt(j+1));
					}
					population[i].fitness /= 4000;
					population[i].fitness = population[i].fitness - temp + 1;
				}
				break;
			case 15:
				for(int i = 1;i <= size;i++){
					CreateMatrix(MResult);
					population[i].fitness = 0;
					for(int j = 0;j < Genotype.NVARS;j++){
						double y = 0;
						for(int k = 0;k < Genotype.NVARS;k++){
							y += MResult[j][k] * population[i].gene[k];
						}
						population[i].fitness += Math.pow(y,2) - 10 * Math.cos(2 * Math.PI * y) + 10;
					}
				}
				break;
		}
		
		
	}

	public static void select(Genotype[] population,Genotype[] MidPop) throws CloneNotSupportedException{
		for(int i = 1;i <= POPSIZE;i++)
			if(MidPop[i].fitness < population[i].fitness){
				population[i] = (Genotype) MidPop[i].clone();				
			}
	}
	public static boolean keepTheBest(Genotype[] population) throws CloneNotSupportedException{
		double bestf;
		int index;
		if(best == null)
		{
			bestf = population[1].fitness;
			index = 1;
		}
		else{
			bestf = best.fitness;
			index = -1;
		}
		for(int i = 1;i <= POPSIZE;i++){
			if(bestf > population[i].fitness){
				bestf = population[i].fitness;
				index = i;
			}			
		}
		if(index != -1){
			best = (Genotype) population[index].clone();
			return true;
		}
		else 
			return false;
	}
	public static void mutate_rand_1_bin(Genotype[] population,Genotype[] MidPop)throws CloneNotSupportedException{
		for(int p = 1;p <= POPSIZE;p++){
			int ran1 = (int)(POPSIZE * Math.random() + 1);
			while(ran1 == p)
				ran1 = (int)(POPSIZE * Math.random() + 1);
			int ran2 = (int)(POPSIZE * Math.random() + 1);
			while(ran2 == ran1 || ran2 == p)
				ran2 = (int)(POPSIZE * Math.random() + 1);
			int ran3 = (int)(POPSIZE * Math.random() + 1);
			while(ran3 == ran2 || ran3 == ran1 || ran3 == p )
				ran3 = (int)(POPSIZE * Math.random() + 1);
			Genotype temp1 = new Genotype(dim);
			temp1 = (Genotype) population[ran2].clone();
			Genotype temp2 = new Genotype(dim);
			temp2 = (Genotype) population[ran3].clone();			
			Genotype[] temp = new Genotype[row+1];
			for(int i = 1;i <= row;i++){
				temp[i] = new Genotype(dim);
				for(int j = 1;j <= Genotype.NVARS;j++){
					if(oArray[i][j] == 1)
						temp[i].gene[j-1] = temp1.gene[j-1];
					else
						temp[i].gene[j-1] = temp2.gene[j-1];
				}				
			}
			evaluate(temp,row,f);
			double[][] tempfit = new double[Genotype.NVARS+1][Genotype.LEVEL+1];
			Genotype ctemp = new Genotype(dim);
			for(int i = 1;i <= Genotype.NVARS;i++){
				double min = 0x7fffffff;
				int index = -1;
				for(int j = 0;j < Genotype.LEVEL;j++){
					tempfit[i][j] = 0;
					int count = 0;
					for(int k = 1;k <= row;k++){
						if(oArray[k][i] == j){
							tempfit[i][j] += temp[k].fitness;
							count++;
						}
					}
					tempfit[i][j] /= count;
					if(min > tempfit[i][j]){
						min = tempfit[i][j];
						index = j;
					}
				}
				if(index == 0)
					ctemp.gene[i-1] = temp2.gene[i-1];
				else
					ctemp.gene[i-1] = temp1.gene[i-1];
				
			}
			Genotype ctemp1 = new Genotype(dim);
			ctemp1 = (Genotype) ctemp.clone();
			int ran4 = (int)(POPSIZE * Math.random() + 1);
			while(ran4 == ran1 || ran4 == ran3 || ran4 == ran2 || ran4 == p)
				ran4 = (int)(POPSIZE * Math.random() + 1);
			int ran5 = (int)(POPSIZE * Math.random() + 1);
			while(ran5 == ran1 || ran5 == ran2 || ran5 == ran3 || ran5 == ran4 || ran5 == p)
				ran5 = (int)(POPSIZE * Math.random() + 1);
			temp1 = (Genotype)population[ran4].clone();
			temp2 = (Genotype)population[ran5].clone();
			//System.out.printf("%d %d %d %d %d\n", ran1,ran2,ran3,ran4,ran5);
			for(int i = 1;i <= row;i++){
				temp[i] = new Genotype(dim);
				for(int j = 1;j <= Genotype.NVARS;j++){
					if(oArray[i][j] == 1)
						temp[i].gene[j-1] = temp1.gene[j-1];
					else
						temp[i].gene[j-1] = temp2.gene[j-1];
				}				
			}
			evaluate(temp,row,f);
			tempfit = new double[Genotype.NVARS+1][Genotype.LEVEL+1];
			ctemp = new Genotype(dim);
			for(int i = 1;i <= Genotype.NVARS;i++){
				double max = 0;
				int index = -1;
				for(int j = 0;j < Genotype.LEVEL;j++){
					tempfit[i][j] = 0;
					int count = 0;
					for(int k = 1;k <= row;k++){
						if(oArray[k][i] == j){
							tempfit[i][j] += temp[k].fitness;
							count++;
						}
					}
					tempfit[i][j] /= count;
					if(max < tempfit[i][j]){
						max = tempfit[i][j];
						index = j;
					}
				}
				//System.out.printf("%f %f\n", ctemp.gene[i-1],ctemp1.gene[i-1]);
				if(index == 0)
					ctemp.gene[i-1] = temp2.gene[i-1];
				else
					ctemp.gene[i-1] = temp1.gene[i-1];
				//System.out.printf("%f %f\n", ctemp.gene[i-1],ctemp1.gene[i-1]);
				
			}
			for(int j = 0;j < Genotype.NVARS;j++){
				MidPop[p].gene[j] = population[ran1].gene[j] + Genotype.SCALE * 
										(ctemp1.gene[j] - ctemp.gene[j]);
				if(MidPop[p].gene[j] < population[ran1].lower[j] || MidPop[p].gene[j] > population[ran1].upper[j])
					MidPop[p].gene[j] = Math.random() * (population[ran1].upper[j] - population[ran1].lower[j])
										+ population[ran1].lower[j];
			}
			//MidPop[p].gene = ctemp.gene.clone();			
		}		
	}
	public static void mutate(Genotype[] population,Genotype[] MidPop) throws CloneNotSupportedException{
		for(int i = 1;i <= POPSIZE;i++){			
			int ran1 = (int)(POPSIZE * Math.random() + 1);
			while(ran1 == i)
				ran1 = (int)(POPSIZE * Math.random() + 1);
			Genotype temp1 = (Genotype) population[ran1].clone();
			int ran2 = (int)(POPSIZE * Math.random() + 1);
			while(ran2 == ran1 || ran2 == i ){
				ran2 = (int)(POPSIZE * Math.random() + 1);
			}
			Genotype temp2 = (Genotype) population[ran2].clone();
			int ran3 = (int)(POPSIZE * Math.random() + 1);
			while(ran3 == ran1 || ran3 == ran2 || ran3 == i)
				ran3 = (int)(POPSIZE * Math.random() + 1);
			for(int j = 0;j < Genotype.NVARS;j++){
				MidPop[i].gene[j] = population[ran3].gene[j] + Genotype.SCALE * 
										(temp1.gene[j] - temp2.gene[j]);
				if(MidPop[i].gene[j] < population[ran3].lower[j] || MidPop[i].gene[j] > population[ran3].upper[j])
					MidPop[i].gene[j] = Math.random() * (population[ran3].upper[j] - population[ran3].lower[j])
										+ population[ran3].lower[j];
			}
		}
	}
	public static void createOA(){
		row = (int)(Math.pow(2.0, Math.ceil(Math.log(Genotype.NVARS+1) / Math.log(2))));
		int col = row - 1;		
		int u = (int)(Math.log(row) / Math.log(2));
		//System.out.println(u);
		oArray = new int[row+2][col+2];
		for(int i = 1;i <= row;i++){
			for(int k = 1;k <= u;k++){
				int j = (int)Math.pow(2,k-1);
				oArray[i][j] = (int)(Math.floor((i - 1) / Math.pow(2,u-k))) % 2;
			}
		}
		
		for(int i = 1;i <= row;i++){
			for(int k = 2;k <= u;k++){
				int j = (int)(Math.pow(2, k-1));
				for(int s = 1; s <= j-1;s++){
					oArray[i][j+s] = (oArray[i][s]+ oArray[i][j]) % 2;
				}
			}
		}
		
		for(int i = 1;i <= row;i++){
			for(int j = 1;j <= col;j++){
				System.out.print(oArray[i][j]);
				System.out.print(" ");
			}
			System.out.println(' ');
		}
		
	}
	public static void orthCross(Genotype[] population,Genotype[] MidPop){
		for(int p = 1;p <= POPSIZE;p++){
			Genotype[] temp = new Genotype[row+2];
			for(int i = 1;i <= row;i++){
				temp[i] = new Genotype(dim);
				for(int j = 1;j <= Genotype.NVARS;j++){
					if(oArray[i][j] == 1)
						temp[i].gene[j-1] = population[p].gene[j-1];
					else
						temp[i].gene[j-1] = MidPop[p].gene[j-1];
				}				
			}
			evaluate(temp,row,f);
			double[][] tempfit = new double[Genotype.NVARS+1][Genotype.LEVEL+1];
			Genotype ctemp = new Genotype(dim);
			for(int i = 1;i <= Genotype.NVARS;i++){
				double min = -1;
				int index = -1;
				for(int j = 0;j < Genotype.LEVEL;j++){
					tempfit[i][j] = 0;
					int count = 0;
					for(int k = 1;k <= row;k++){
						if(oArray[k][i] == j){
							tempfit[i][j] += temp[k].fitness;
							count++;
						}
					}
					tempfit[i][j] /= count;
					if(index == -1){
						min = tempfit[i][j];
						//System.out.println(min);
						index = j;
					}
					else if(min > tempfit[i][j]){
						min = tempfit[i][j];
						//System.out.println(min);
						index = j;
					}
				}
				if(index == 0)
					ctemp.gene[i-1] = MidPop[p].gene[i-1];
				else
					ctemp.gene[i-1] = population[p].gene[i-1];
				
			}
			MidPop[p].gene = ctemp.gene.clone();			
		}		
	}
	public static void cross(Genotype[] population,Genotype[] MidPop){
		for(int i = 1;i <= POPSIZE;i++){
			int jrand = (int) (Math.random() * Genotype.NVARS);
			if(jrand == Genotype.NVARS)
				jrand--;
			for(int j = 0;j < Genotype.NVARS;j++){
				if(Math.random() > Genotype.PXOVER && j != jrand){
					MidPop[i].gene[j] = population[i].gene[j];
					//System.out.printf("%f %f\n",MidPop[i].gene[j],population[i].gene[j]);
				}
			}
		}
	}
	public static void main(String[] args) throws FileNotFoundException, CloneNotSupportedException{
		System.out.println("sjfklsd");
		CreateMatrix(MResult);
		for(f = 12;f <= 14;f++){
			Genotype[] population = new Genotype[POPSIZE+1];
			//Genotype[] newPopulation = new Genotype[POPSIZE+1];
			Genotype[] MidPop = new Genotype[POPSIZE+1];
			best = null;
			
	 		for(int i = 0;i <= POPSIZE;i++){
	 			population[i] = new Genotype(dim);
	 			MidPop[i] = new Genotype(dim);
	 		}
			createOA();
			MResult = new double[Genotype.NVARS][Genotype.NVARS];
			MTurn = new double[Genotype.NVARS][Genotype.NVARS];
			init(population,MidPop);
			int generation = 0;
			while(generation <= MAXGENS){
				
				System.out.println(generation);
				mutate(population,MidPop);
				//orthCross(population,MidPop);
				cross(population,MidPop);
				evaluate(population,POPSIZE,f);
				if(keepTheBest(population))
					generation = 0;
				else
					generation++;
				evaluate(MidPop,POPSIZE,f);
				select(population,MidPop);
				
			}
			String filename = "/home/ryan/testdata/output" + f + ".txt";
			PrintWriter output = new PrintWriter(new File(filename));
			for(int i = 1;i <= POPSIZE;i++){
				output.printf("Pop  %.15f %.15f %.15f\n",population[i].gene[0],population[i].gene[1],population[i].fitness);
				output.printf("MidPop  %.15f %.15f %.15f\n",MidPop[i].gene[0],MidPop[i].gene[1],MidPop[i].fitness);
			}
			output.print("best: ");
			output.println(best.fitness);
			for(int i = 0;i < Genotype.NVARS;i++)
				output.println(best.gene[i]);
			output.close();
			/*System.out.println(best.fitness);
			for(int i = 0;i < Genotype.NVARS;i++)
				System.out.println(best.gene[i]);*/
		}
		
		
		
		/*Genotype a = new Genotype(dim);
		//Genotype b = new Genotype(dim);
		a.fitness = 30;
		a.gene[1] = 23;
		Genotype b = (Genotype) a.clone();
		b.fitness = 50;
		b.gene[1] = a.gene[1];
		a.gene[1] = 26;
		//a.gene[1] = 53;
		System.out.printf("%f %f %f %f",a.fitness,b.fitness,a.gene[1],b.gene[1]);*/
	}
}
