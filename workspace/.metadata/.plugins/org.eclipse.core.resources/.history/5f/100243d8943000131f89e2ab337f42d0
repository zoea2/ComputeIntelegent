package differentialEvolution;

import java.io.*;
import java.util.Scanner;

public class DE {
	final static int POPSIZE = 100;
	final static int MAXGENS = 5000;
	final static int dim = 2;
	static Genotype best;
	static int[][] oArray;
	static int row;
	public static void init(Genotype[] population,Genotype[] MidPop) throws FileNotFoundException{
		double lbound;
		double ubound;
		Scanner input = new Scanner(new File("/home/ryan/bound.txt"));		
		for(int i = 0;i < Genotype.NVARS;i++){
			lbound = input.nextDouble();
			ubound = input.nextDouble();
			System.out.println(lbound);
			System.out.println(ubound);
			for(int j = 0;j < POPSIZE;j++){
				population[j].fitness = 0.0;
				//population[j].cfitness = 0;
				//population[j].rfitness = 0;
				population[j].lower[i] = lbound;
				population[j].upper[i] = ubound;
				MidPop[j].lower[i] = lbound;
				MidPop[j].upper[i] = ubound;
				population[j].gene[i] = Math.random() * 
						(population[j].upper[i] - population[j].lower[i]) + 
						population[j].lower[i];
			}
		}
		input.close();
		/*
		PrintWriter output = new PrintWriter(new File("/home/ryan/output.txt"));
		for(int i = 0;i < POPSIZE;i++){
			output.printf("Pop  %f %f %f\n",population[i].gene[0],population[i].gene[1],population[i].fitness);
			//output.printf("MidPop  %f %f %f\n",MidPop[i].gene[0],MidPop[i].gene[1],MidPop[i].fitness);
		}
		output.close();
		*/
	}
	public static void evaluate(Genotype[] population){
		for(int i = 0;i < POPSIZE;i++){
			double x1 = population[i].gene[0];
			double x2 = population[i].gene[1];
			population[i].fitness = 21.5 + x1 * Math.sin(4*Math.PI*x1)+x2*Math.sin(20*Math.PI*x2);
			//System.out.printf("popsize %d fitness %f \n",i,population[i].fitness);
		}
	}
	public static void evaluate(Genotype[] population,int size){
		for(int i = 1;i <= size;i++){
			double x1 = population[i].gene[0];
			double x2 = population[i].gene[1];
			population[i].fitness = 21.5 + x1 * Math.sin(4*Math.PI*x1)+x2*Math.sin(20*Math.PI*x2);
			//System.out.printf("popsize %d fitness %f \n",i,population[i].fitness);
		}
	}
	public static void select(Genotype[] population,Genotype[] MidPop) throws CloneNotSupportedException{
		for(int i = 0;i < POPSIZE;i++)
			if(MidPop[i].fitness > population[i].fitness){
				population[i] = (Genotype) MidPop[i].clone();
				
			}
	}
	public static void keepTheBest(Genotype[] population) throws CloneNotSupportedException{
		double bestf;
		int index;
		if(best == null)
		{
			bestf = population[0].fitness;
			index = 0;
		}
		else{
			bestf = best.fitness;
			index = -1;
		}
		for(int i = 1;i < POPSIZE;i++){
			if(bestf < population[i].fitness){
				bestf = population[i].fitness;
				index = i;
			}			
		}
		if(index != -1)
			best = (Genotype) population[index].clone();
	}
	public static void mutate_rand_1_bin(Genotype[] population,Genotype[] MidPop)throws CloneNotSupportedException{
		for(int p = 0;p < POPSIZE;p++){
			int ran1 = (int)(POPSIZE * Math.random());
			while(ran1 == p || ran1 == POPSIZE && p == POPSIZE - 1)
				ran1 = (int)(POPSIZE * Math.random());
			if(ran1 == POPSIZE)
				ran1--;
			int ran2 = (int)(POPSIZE * Math.random());
			while(ran2 == ran1 || ran2 == p || ran2 == POPSIZE && (ran1 == POPSIZE - 1 || p == POPSIZE - 1))
				ran2 = (int)(POPSIZE * Math.random());
			if(ran2 == POPSIZE)
				ran2--;
			int ran3 = (int)(POPSIZE * Math.random());
			while(ran3 == ran2 || ran3 == ran1 || ran3 == p || ran3 == POPSIZE &&(ran2 == POPSIZE - 1 || ran1 == POPSIZE - 1 || p == POPSIZE - 1))
				ran3 = (int)(POPSIZE * Math.random());
			if(ran3 == POPSIZE)
				ran3--;
			Genotype temp1 = new Genotype(dim);
			temp1 = (Genotype) population[ran2].clone();
			Genotype temp2 = new Genotype(dim);
			temp2 = (Genotype) population[ran3].clone();			
			Genotype[] temp = new Genotype[row+1];
			for(int i = 1;i <= row;i++){
				temp[i] = new Genotype(dim);
				for(int j = 1;j <= Genotype.NVARS;j++){
					if(oArray[i][j] == 1)
						temp[i].gene[j-1] = temp1.gene[j-1];
					else
						temp[i].gene[j-1] = temp2.gene[j-1];
				}				
			}
			evaluate(temp,row);
			double[][] tempfit = new double[Genotype.NVARS+1][Genotype.NVARS+1];
			Genotype ctemp = new Genotype(dim);
			for(int i = 1;i <= Genotype.NVARS;i++){
				double max = 0;
				int index = -1;
				for(int j = 0;j < Genotype.NVARS;j++){
					tempfit[i][j] = 0;
					int count = 0;
					for(int k = 1;k <= row;k++){
						if(oArray[k][i] == j){
							tempfit[i][j] += temp[k].fitness;
							count++;
						}
					}
					tempfit[i][j] /= count;
					if(max < tempfit[i][j]){
						max = tempfit[i][j];
						index = j;
					}
				}
				if(index == 0)
					ctemp.gene[i-1] = temp2.gene[i-1];
				else
					ctemp.gene[i-1] = temp1.gene[i-1];
				
			}
			Genotype ctemp1 = (Genotype) ctemp.clone();
			int ran4 = (int)(POPSIZE * Math.random());
			while(ran4 == ran1 || ran4 == ran3 || ran4 == ran2 || ran4 == p || ran4 == POPSIZE 
					&& (ran1 == POPSIZE - 1 || ran2 == POPSIZE - 1 || ran3 == POPSIZE - 1 || p == POPSIZE - 1))
				ran4 = (int)(POPSIZE * Math.random());
			if(ran4 == POPSIZE)
				ran4--;
			int ran5 = (int)(POPSIZE * Math.random());
			while(ran5 == ran1 || ran5 == ran2 || ran5 == ran3 || ran5 == ran4 || ran5 == p 
					|| ran5 == POPSIZE &&(ran1 == POPSIZE - 1 || ran2 == POPSIZE - 1 || ran3 == POPSIZE - 1 
					|| ran4 == POPSIZE - 1 || p == POPSIZE - 1))
				ran5 = (int)(POPSIZE * Math.random());
			if(ran5 == POPSIZE)
				ran5--;
			temp1 = (Genotype)population[ran4].clone();
			temp2 = (Genotype)population[ran5].clone();
			for(int i = 1;i <= row;i++){
				//temp[i] = new Genotype(dim);
				for(int j = 1;j <= Genotype.NVARS;j++){
					if(oArray[i][j] == 1)
						temp[i].gene[j-1] = temp1.gene[j-1];
					else
						temp[i].gene[j-1] = temp2.gene[j-1];
				}				
			}
			evaluate(temp,row);
			tempfit = new double[Genotype.NVARS+1][Genotype.NVARS+1];
			ctemp = new Genotype(dim);
			for(int i = 1;i <= Genotype.NVARS;i++){
				double max = 0;
				int index = -1;
				for(int j = 0;j < Genotype.NVARS;j++){
					tempfit[i][j] = 0;
					int count = 0;
					for(int k = 1;k <= row;k++){
						if(oArray[k][i] == j){
							tempfit[i][j] += temp[k].fitness;
							count++;
						}
					}
					tempfit[i][j] /= count;
					if(max < tempfit[i][j]){
						max = tempfit[i][j];
						index = j;
					}
				}
				if(index == 0)
					ctemp.gene[i-1] = temp2.gene[i-1];
				else
					ctemp.gene[i-1] = temp1.gene[i-1];
				
			}
			for(int j = 0;j < Genotype.NVARS;j++){
				MidPop[p].gene[j] = population[ran1].gene[j] + Genotype.SCALE * 
										(ctemp1.gene[j] - ctemp.gene[j]);
				if(MidPop[p].gene[j] < population[ran1].lower[j] || MidPop[p].gene[j] > population[ran1].upper[j])
					MidPop[p].gene[j] = Math.random() * (population[ran1].upper[j] - population[ran1].lower[j])
										+ population[ran1].lower[j];
			}
			//MidPop[p].gene = ctemp.gene.clone();			
		}		
	}
	public static void mutate(Genotype[] population,Genotype[] MidPop) throws CloneNotSupportedException{
		for(int i = 0;i < POPSIZE;i++){			
			int ran1 = (int)(POPSIZE * Math.random());
			while(ran1 == i || ran1 == POPSIZE && i == POPSIZE - 1)
				ran1 = (int)(POPSIZE * Math.random());
			Genotype temp1 = (Genotype) population[ran1].clone();
			if(ran1 == POPSIZE)
				ran1--;
			int ran2 = (int)(POPSIZE * Math.random());
			while(ran2 == ran1 || ran2 == POPSIZE && ran1 == ran2 - 1 || ran2 == i || ran2 == POPSIZE && i == POPSIZE - 1){
				ran2 = (int)(POPSIZE * Math.random());
			}
			if(ran2 == POPSIZE)
				ran2--;
			Genotype temp2 = (Genotype) population[ran2].clone();
			int ran3 = (int)(POPSIZE * Math.random());
			while(ran3 == ran1 || ran3 == ran2 || ran3 == i ||ran3 == POPSIZE && (i == POPSIZE -1 || ran1 == POPSIZE - 1 || ran2 == POPSIZE - 1))
				ran3 = (int)(POPSIZE * Math.random());
			if(ran3 == POPSIZE)
				ran3--;
			for(int j = 0;j < Genotype.NVARS;j++){
				MidPop[i].gene[j] = population[ran3].gene[j] + Genotype.SCALE * 
										(temp1.gene[j] - temp2.gene[j]);
				if(MidPop[i].gene[j] < population[ran3].lower[j] || MidPop[i].gene[j] > population[ran3].upper[j])
					MidPop[i].gene[j] = Math.random() * (population[ran3].upper[j] - population[ran3].lower[j])
										+ population[ran3].lower[j];
			}
		}
	}
	public static void createOA(){
		row = (int)(Math.pow(2.0, Math.ceil(Math.log(Genotype.NVARS+1) / Math.log(2))));
		int col = row - 1;		
		int u = (int)(Math.log(row) / Math.log(2));
		//System.out.println(u);
		oArray = new int[row+2][col+2];
		for(int i = 1;i <= row;i++){
			for(int k = 1;k <= u;k++){
				int j = (int)Math.pow(2,k-1);
				oArray[i][j] = (int)(Math.floor((i - 1) / Math.pow(2,u-k))) % Genotype.NVARS;
			}
		}
		
		for(int i = 1;i <= row;i++){
			for(int k = 2;k <= u;k++){
				int j = (int)(Math.pow(2, k-1));
				for(int s = 1; s <= j-1;s++){
					oArray[i][j+s] = (oArray[i][s]+ oArray[i][j]) % Genotype.NVARS;
				}
			}
		}
		
		for(int i = 1;i <= row;i++){
			for(int j = 1;j <= col;j++){
				System.out.print(oArray[i][j]);
				System.out.print(" ");
			}
			System.out.println(' ');
		}
		
	}
	public static void orthCross(Genotype[] population,Genotype[] MidPop){
		for(int p = 0;p < POPSIZE;p++){
			Genotype[] temp = new Genotype[row+1];
			for(int i = 1;i <= row;i++){
				temp[i] = new Genotype(dim);
				for(int j = 1;j <= Genotype.NVARS;j++){
					if(oArray[i][j] == 1)
						temp[i].gene[j-1] = population[p].gene[j-1];
					else
						temp[i].gene[j-1] = MidPop[p].gene[j-1];
				}				
			}
			evaluate(temp,row);
			double[][] tempfit = new double[Genotype.NVARS+1][Genotype.NVARS+1];
			Genotype ctemp = new Genotype(dim);
			for(int i = 1;i <= Genotype.NVARS;i++){
				double max = 0;
				int index = -1;
				for(int j = 0;j < Genotype.NVARS;j++){
					tempfit[i][j] = 0;
					int count = 0;
					for(int k = 1;k <= row;k++){
						if(oArray[k][i] == j){
							tempfit[i][j] += temp[k].fitness;
							count++;
						}
					}
					tempfit[i][j] /= count;
					if(max < tempfit[i][j]){
						max = tempfit[i][j];
						index = j;
					}
				}
				if(index == 0)
					ctemp.gene[i-1] = MidPop[p].gene[i-1];
				else
					ctemp.gene[i-1] = population[p].gene[i-1];
				
			}
			MidPop[p].gene = ctemp.gene.clone();			
		}		
	}
	public static void cross(Genotype[] population,Genotype[] MidPop){
		for(int i = 0;i < POPSIZE;i++){
			int jrand = (int) (Math.random() * Genotype.NVARS);
			if(jrand == Genotype.NVARS)
				jrand--;
			for(int j = 0;j < Genotype.NVARS;j++){
				if(Math.random() > Genotype.PXOVER && j != jrand){
					MidPop[i].gene[j] = population[i].gene[j];
					//System.out.printf("%f %f\n",MidPop[i].gene[j],population[i].gene[j]);
				}
			}
		}
	}
	public static void main(String[] args) throws FileNotFoundException, CloneNotSupportedException{
		System.out.println("sjfklsd");
		Genotype[] population= new Genotype[POPSIZE+1];
		//Genotype[] newPopulation = new Genotype[POPSIZE+1];
		Genotype[] MidPop = new Genotype[POPSIZE+1];
		best = null;

		
 		for(int i = 0;i <= POPSIZE;i++){
 			population[i] = new Genotype(dim);
 			MidPop[i] = new Genotype(dim);
 		}
		createOA();
		
		init(population,MidPop);
		int generation = 0;
		while(generation < MAXGENS){
			generation++;
			System.out.println(generation);
			mutate_rand_1_bin(population,MidPop);
			//orthCross(population,MidPop);
			cross(population,MidPop);
			evaluate(population);
			keepTheBest(population);
			evaluate(MidPop);
			select(population,MidPop);
			
		}
		PrintWriter output = new PrintWriter(new File("/home/ryan/output.txt"));
		for(int i = 0;i < POPSIZE;i++){
			output.printf("Pop  %f %f %f\n",population[i].gene[0],population[i].gene[1],population[i].fitness);
			output.printf("MidPop  %f %f %f\n",MidPop[i].gene[0],MidPop[i].gene[1],MidPop[i].fitness);
		}
		output.close();
		System.out.println(best.fitness);
		System.out.printf("%f %f\n",best.gene[0],best.gene[1]);	
		/*Genotype a = new Genotype(dim);
		//Genotype b = new Genotype(dim);
		a.fitness = 30;
		a.gene[1] = 23;
		Genotype b = (Genotype) a.clone();
		b.fitness = 50;
		b.gene[1] = a.gene[1];
		a.gene[1] = 26;
		//a.gene[1] = 53;
		System.out.printf("%f %f %f %f",a.fitness,b.fitness,a.gene[1],b.gene[1]);*/
	}
}
